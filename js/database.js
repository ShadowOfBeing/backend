/*
<4s> - кастомный тег для обозначения отступа в 4 пробела, в функции getAnswer() заменяется на &nbsp;&nbsp;&nbsp;&nbsp;
что создаёт на в тексте отступ в 4 пробела. Сделан, чтобы каждый раз не прописывать &nbsp;&nbsp;&nbsp;&nbsp;
*/

links = {
    'python': ['https://youtube.com/playlist?list=PLA0M1Bcd0w8yWHh2V70bTtbVxJICrnJHd'],
    'oop': ['https://youtube.com/playlist?list=PLA0M1Bcd0w8zPwP7t-FgwONhZOHt9rz9E',
            'https://youtu.be/TxZwqVTaCmA',
            'https://youtu.be/-6DWwR_R4Xk'],
}

answersAndQuestions = {
    'work': {
        1: {'question': 'Расскажите о себе', 'answer': 'Кратко описываем свои последние места работы и стек'},
        2: {'question': 'Почему вы уволились с последнего места работы?', 'answer': 'work_place answer 2'},
        3: {'question': 'Расскажите о самом интересном своём проекте', 'answer': 'work_place answer 3'},
        4: {'question': 'Расскажите о самом большом своём факапе', 'answer': 'Рассказать используя концепцию SMART'},
        5: {'question': 'Опишите свой последний рабочий проект', 'answer': 'Рассказать про последний проект'},
        6: {'question': 'Опишите какая была команда и стек на последнем месте', 'answer': 'Рассказать про тимлидов, бэкендеров/фронтов/тестировщиков, описать стек'},
        7: {'question': 'Опишите как был устроен рабочий процесс на последнем месте работы', 'answer': `Описать кто писал ТЗ,
                         кто создавал и назначал задачи, как задачи брали в работу, как сдавали задачи, как контролировали сроки, как проходило code review.`},
        8: {'question': 'Какие ваши ожидания от нового места работы? В какой компании/проекте хотели бы работать?',
            'answer': 'Можно сказать, что ищешь интересный проект с достойной зарплатой и развитием по хардскилам и карьере.'},
        9: {'question': 'По каким критериям будете выбирать из нескольких офферов?',
            'answer': `Можно сказать, что в первую очередь будешь смотреть на то насколько интересный проект и на зарплату,
                       затем какое развитие могут предложить (по хардскилам и по карьере), если всё перечисленное примерно
                       одинаковое, то выберешь более известную компанию.`},
    },
    'python': {
        1: {'question': 'Ссылки на материалы для изучения',
            'answer': `1) <a href="${links['python'][0]}" target="_blank">Курс по Python</a> от Сергея Балакирева<br>`},
        2: {'question': 'Что такое asyncio?',
            'answer': `Asyncio (Asynchronous Input/Output) - это библиотека для написания асинхронного кода с
                       использованием синтаксиса async/await в Python. Она предоставляет асинхронную основу для многих
                       Python фреймворков, использующих асинхронное программирование. Благодаря asyncio можно
                       одновременно обрабатывать большое количество запросов, обращаться к внешним сервисам и
                       улучшить производительность веб-приложений.`},
        3: {'question': 'Как в Python работает многопроцессорность, многопоточность и асинхронность?',
            'answer': `Многопроцессорность в Python реализуется через библиотеку multiproccesing.<br>
                       <br>
                       Многопоточность в Python реализуется через библиотеку threading.<br>
                       <br>
                       Асинхронность в Python реализуется через библиотеку asyncio.`},
        4: {'question': 'Что такое GIL?',
            'answer': `GIL (Global Interpreter Lock) - это механизм в CPython (стандартной реализации Python), который
                       предназначен для обеспечения потокобезопасности , ограничивая выполнение кусков байткода Python
                       только одним потоком в любое время.
                       <br><br>
                       GIL блокирует объект интерпретатора, что позволяет только одному потоку Python выполнять байткод
                       в конкретный момент времени. Это нужно для того, чтобы гарантировать, что изменения в памяти не
                       приводят к недопустимым состояниям, таким как гонки данных или состояния гонок, т.е. для защиты
                       структуры данных интерпретатора, который имеет глобальную область видимости.
                       <br><br>
                       Вследствие этого GIL может ограничивать производительность многопоточных приложений. Хотя многие
                       операции в Python, такие как ввод-вывод или работа с сетью, могут проходить без блокировки GIL,
                       многопоточные приложения, к примеру, производящие вычисления, в большинстве случаев не получают
                       ощутимого преимущества от использования нескольких потоков.
                       <br><br>
                       Некоторые реализации Python, такие как Jython и IronPython, не имеют GIL и опираются на другие
                       механизмы для обеспечения потокобезопасности.`},
        5: {'question': 'Как работает сборщик мусора в Python?',
            'answer': `Сборщик мусора в Python отслеживает объекты, которые не имеют ссылок на себя из других объектов,
                       и освобождает память, занимаемую такими объектами. Он автоматически обрабатывает память и удаляет
                       из нее объекты, которые больше не используются в программе, что упрощает работу программиста и
                       предотвращает утечки памяти.
                       <br><br>
                       В Python используется разновидность сборщика мусора, называемая "генерационным". Он разделяет
                       объекты на три поколения: молодое поколение, поколение следующего уровня и долгоживущие объекты.
                       Большинство объектов быстро становятся мусором и собираются в молодом поколении, но если они
                       переживают несколько сборок мусора, то перемещаются в поколение следующего уровня для более
                       тщательной обработки.`},
        6: {'question': 'Как в Python устроены словари?',
            'answer': `В Python словари (dict) устроены как хеш-таблицы, что делает их очень эффективными для быстрого
                       поиска и доступа к данным. В словарях представлены данные в виде ключей и значений, где каждый
                       ключ должен быть уникальным.
                       <br><br>
                       При добавлении элемента в словарь, Python использует хеш-функцию для определения индекса, по
                       которому он должен храниться. При поиске элемента Python повторно использует эту хеш-функцию для
                       поиска индекса, что делает поиск элементов в словаре очень быстрым. По этой же причине в качестве
                       ключа можно использовать только неизменяемый тип данных.
                       <br><br>
                       Словари в Python являются изменяемым типом данных, что означает, что они могут изменяться в
                       процессе выполнения программы. Они также являются контейнерным типом данных, что позволяет
                       хранить в них любые другие типы данных, включая списки, кортежи и даже другие словари.`},
        7: {'question': 'Как в Python устроены списки?', 'answer': 'python answer 6'},
        8: {'question': 'Какие изменяемые и неизменяемые типы данных есть в Python?', 'answer': 'python answer 7'},
        9: {'question': 'Что такое вещественные и ссылочные типы данных?', 'answer': 'python answer 8'},
        10: {'question': 'Что такое List Comprehensions?', 'answer': 'python answer 9'},
        11: {'question': 'Что такое генератор (yield) в Python?',
             'answer': 'python answer 10'},
        12: {'question': 'Что такое декораторы в Python? Как написать свой декоратор?', 'answer': 'python answer 11'},
        13: {'question': 'Какие есть изменения в версиях Python 2.x/3.x?',
             'answer': `Версия 2.2 (21 дек 2001):<br>
                        - классам добавлен базовый класс object<br>
                        Версия 3.4 (16 мар 2014):<br>
                        - добавлена библиотека asyncio (асинхронность)<br>
                        Версия 3.5 (13 сен 2015):<br>
                        - добавлена библиотека typing (аннотация типов)<br>
                        Версия 3.8 (21 окт 2019):<br>
                        - добавлен моржовый оператор (:=)<br>
                        Версия 3.10 (4 окт 2021):<br>
                        - добавлено перечисление типов через знак | (может использоваться например в аннотации типов
                        или в проверке isinstance())<br>
                        - улучшена безопасность (труднее декомпозировать exe-файл в исходный python-код)<br>
                        - добавлена конструкция match-case`},
        14: {'question': 'Что делает функция enumerate?', 'answer': 'python answer 13'},
        15: {'question': 'Что делает функция zip?', 'answer': 'python answer 14'},
        16: {'question': 'Как в Python отловить ошибку, чтобы она не сломала программу?', 'answer': 'python answer 15'},
        17: {'question': 'Что такое распаковка в Python?',
             'answer': `Распаковка в Python - это процесс извлечения элементов из последовательностей (словарей,
                        кортежей или списков) и присвоения их переменным. В Python для распаковки последовательностей
                        используются операторы * и ** для кортежей и словарей соответственно. Оператор * распаковывает
                        последовательность и передает отдельные элементы в функцию в качестве отдельных аргументов (в
                        случае словаря - ключи), а оператор ** распаковывает словарь и передает его значения по ключу.
                        Распаковка может использоваться для удобного прохода по элементам последовательностей, передачи
                        аргументов в функции или присваивания значений переменным в одной строке кода. Например:<br>
                        my_list = (1, 2, 3)<br>
                        a, b, c = *my_list<br>
                        print(a, b, c)<br>
                        В консоль будет выведено 1, 2, 3<br>
                        <br>
                        или<br>
                        <br>
                        my_dict = {'a': 1, 'b': 2, 'c': 3}<br>
                        d, e, f = **my_dict<br>
                        print(d, e, f)<br>
                        В консоль будет выведено 1, 2, 3`},
        18: {'question': 'Зачем нужна конструкция if __name__ == "__main__"?',
             'answer': `В Python-файле может присутствовать код, который не обёрнут в функцию, такой код выполнится
                        при запуске файла. Однако python-файл может использоваться не только как исполняемый
                        файл, но и как хранилище кода (модуль), в таком случае файл подключают (импортируют) к другому
                        python-файлу и используют из него функции по необходимости.<br>
                        Конструкция if __name__ == "__main__" объявляет, что если обращение к этому файлу происходит из
                        другого файла, то код в этом файле не обёрнутый в функции не будет выполняться.`},
        19: {'question': 'Что такое args и kwargs в Python?',
             'answer': `В Python это специальные параметры, которые позволяют передавать различное количество аргументов
                        в функцию.<br>
                        <br>
                        - args - это параметр функции, который позволяет передавать переменное количество позиционных
                        аргументов. Имя args может быть любым, но обычно используется именно args. Параметр args
                        представляется в виде кортежа (tuple) и позволяет передавать неограниченное количество аргументов
                        позиционно. Функция может распаковать этот кортеж и обрабатывать каждый аргумент отдельно.
                        Пример использования *args:<br>
                        def my_function(*args):<br>
                        <4s>for arg in args:<br>
                        <4s><4s>print(arg)<br>
                        <br>
                        my_function(1, 2, 3)<br>
                        <br>
                        <br>
                        Будет выведено в консоль:<br>
                        1<br>
                        2<br>
                        3<br>
                        <br>
                        kwargs - это параметр функции, который позволяет передавать переменное количество именованных
                        аргументов. Имя kwargs может быть любым, но обычно используется именно kwargs. Параметр kwargs
                        представляется в виде словаря (dictionary) и позволяет передавать неограниченное количество
                        именованных аргументов. Функция может использовать этот словарь для доступа к каждому аргументу
                        по имени. Пример использования **kwargs:<br>
                        def my_function(*args):<br>
                        <4s>for arg in args:<br>
                        <4s><4s>print(arg)<br>
                        <br>
                        <br>
                        my_function(1, 2, 3)<br>
                        Вывод:<br>
                        1<br>
                        2<br>
                        3`},
        20: {'question': 'Какие типы параметров есть в Python?',
             'answer': `В функциях Python есть 4 типа параметров:<br>
                        1) Позиционные параметры - значения таким аргументам присваиваются в той последовательности, в
                        которой они объявлены в функции<br>
                        2) Именованные параметры - параметры, которые значения в которые передаются по имени параметра.<br>
                        3) *args - параметр с переменным количеством позиционных аргументов. Параметр args представляется
                        в виде кортежа (tuple) и позволяет передавать неограниченное количество аргументов позиционно.
                        Функция может распаковать этот кортеж и обрабатывать каждый аргумент отдельно.<br>
                        4) *kwargs - параметр с переменным количеством именованных аргументов. Параметр kwargs
                        представляется в виде словаря (dictionary) и позволяет передавать неограниченное количество
                        именованных аргументов. Функция может использовать этот словарь для доступа к каждому аргументу
                        по имени.<br>
                        <br>
                        Все параметры кроме позиционных являются опциональными, т.е. необязательными при вызове функции.
                        В Python параметры разных видов имеют установленный порядок - они должны располагаться в том же
                        порядке, в каком описаны выше.`},
        21: {'question': 'В чём отличие global от nonlocal?',
             'answer': `В Python ключевое слово global означает, что переменная относится к глобальной области видимости
                        за пределами всех функций, а ключевое слово nonlocal означает, что переменная относится к внешнему
                        уровню вложенности, например когда одна функция объявлена внутри другой, то объявление переменной
                        с ключевым словом nonlocal означает, что обращение идёт к переменной в области видимости
                        родительской функции.<br>
                        Пример с global:<br>
                        a = 1<br>
                        <br>
                        <br>
                        def my_function(a):<br>
                        <4s>a += 1<br>
                        <br>
                        <br>
                        def my_other_function(a):<br>
                        <4s>global a<br>
                        <4s>a += 1<br>
                        <br>
                        my_function(2)<br>
                        print(a)<br>
                        my_other_function(5)<br>
                        print(a)<br>
                        <br>
                        Будет выведено:<br>
                        1<br>
                        2<br>
                        <br>
                        Так произошло потому, что нельзя изменять глобальную переменную внутри функции без объявления её
                        как global, соответственно в первой функции произошло обращение к локальной переменной с тем же
                        именем (а если бы не было локальной переменной с таким именем, то произошла бы ошибка). А во
                        второй функции уже есть указание, что следует обращаться именно к переменной за пределами функции,
                        соответственно её значение изменилось.<br>
                        <br>
                        Пример с nonlocal:<br>
                        def counter_1(start=0):<br>
                        <4s>def step():<br>
                        <4s><4s>nonlocal start<br>
                        <4s><4s>start += 1<br>
                        <4s><4s>return start<br>
                        <br>
                        <4s>return step<br>
                        <br>
                        <br>
                        def counter_2(start=0):<br>
                        <4s>def step():<br>
                        <4s><4s>start += 1<br>
                        <4s><4s>return start<br>
                        <br>
                        <4s>return step<br>
                        <br>
                        <br>
                        c1 = counter_1()<br>
                        print(c1)<br>
                        c2 = counter_2()<br>
                        print(c2)<br>
                        <br>
                        После вызова функции counter_1 её результат будет присвоен переменной и выеден в консоль, а при
                        вызове функции counter_2 возникнет ошибка. Так происходит, потому что в первой функции мы явно
                        указали, что к переменной нужно обращаться в родительской области видимости, а во второй функции
                        такого указания нет и функция пытается найти переменную в локальной области видимости и не
                        находит (в глобальной области даже не ищет, потому что без ключевого слова global изменение
                        глобальных переменных запрещены).`},
    22: {'question': 'Что такое хэш в Python?',
         'answer': `В Python хэш - это числовое значение, вычисляемое для любого объекта по определённому алгоритму.
                    В Python для вычисления хэша используется функция hash(). В Python хэш используется например в
                    словарях, для каждого ключа вычисляется хэш и уже он используется для получения соответствующего
                    значения из хэш-таблицы (это сильно ускоряет код, так как для получения данных по хэшу есть
                    специальный алгоритм). Важные замечания про хэш:<br>
                    - если два объекта равны, то у них будет одинаковый хэш, т.е. если object_1 == object_2, то и
                    hash(object_1) == hash(object_2)<br>
                    - если у двух объектов одинаковый хэш, это не обязательно означает, что они равны. С очень маленькой
                    вероятностью хэш может совпасть у разных объектов. Т.е. если hash(object_1) == hash(object_2), то
                    необязательно object_1 == object_2.<br>
                    - если у двух объектов разные хэши, то объекты точно не равны. Т.е. если hash(object_1) != hash(object_2),
                    то object_1 != object_2.<br>
                    - хэш можно вычислять только для неизменяемых объектов (иначе получим ошибку)`},
    },
    'async': {
        1: {'question': 'Есть ли асинхронность в Django?',
            'answer': `Да, начиная с версии Django 3.1 во фреймворк добавили поддержку асинхронности (асинхронные view
                       и middleware), чтобы объявить функцию асинхронной нужно перед def прописать async. С версии 4.1
                       добавили так же асинхронную поддержку ORM Django. В Django используется библиотека asyncio,
                       благодаря методу asyncio.iscoroutinefunction() middleware может работать как в асинхронном,
                       так и в синхронном режиме (метод принимает наш запрос и через ветвление if/else мы прописываем
                       две реализации кода: для синхронного и асинхронного запросов). Пример:<br>
                       import asyncio<br>
                       from django.utils.decorators import sync_and_async_middleware<br>
                       <br>
                       @sync_and_async_middleware<br>
                       def simple_middleware(get_response):<br>
                       <4s>if asyncio.iscoroutinefunction(get_response):<br>
                       <4s><4s>async def middleware(request):<br>
                       <4s><4s><4s>response = await get_response(request)<br>
                       <4s><4s><4s>return response<br>
                       <4s>else:<br>
                       <4s><4s>def middleware(request):<br>
                       <4s><4s><4s>response = get_response(request)<br>
                       <4s><4s><4s>return response<br>
                       <br>
                       Модуль django.utils.decorators содержит декораторы sync_only_middleware(), async_only_middleware()
                       и sync_and_async_middleware(), которые позволяют применять эти флаги к нашим функциям и указывать
                       в каком режиме они должны работать.<br><br>
                       Однако асинхронность в Django всё ещё несёт
                       ряд ограничений, из-за которых эта реализация пока что не пользуется большой популярностью:<br>
                       - Django позволяет использовать в одном проекте и синхронный и асинхронный код, но за счёт
                       такого гибридного использования теряется производительность в 1 миллисекунду.<br>
                       - некоторые глобальные вещи в Django синхронные, так как имеют глобальную область видимости и
                       их нельзя сделать асинхронными из соображений безопасности<br><br>
                       Документация:<br>
                       - <a href="https://django.fun/ru/docs/django/3.1/releases/3.1/#asynchronous-views-and-middleware-support" target="_blank">Django 3.1</a><br>
                       - <a href="https://docs.djangoproject.com/en/4.2/releases/4.1/" target="_blank">Django 4.1</a><br>
                       `},
        2: {'question': 'Что такое async и await?',
            'answer': `async и await - это ключевые слова, используемые при работе с асинхронными функциями в Python. async
                       помечает функцию как асинхронную, а await используется для ожидания результата работы функции.
                       Например:`},
        3: {'question': 'Зачем нужно асинхронное выполнение кода?',
            'answer': `В контексте backend-разработки очень много времени тратится на операции ввода-вывода данных
                       (input/output), асинхронное выполнение кода нужно для того, чтобы выполнять такие операции
                       параллельно. К примеру, чтобы запросы к базе данных не замедляли выполнение кода и выполнялись
                       параллельно остальному коду или когда микросервисы посылают запросы к другим сервисам.`},
        4: {'question': 'Для каких задач применяется asynсio в Django проекте?',
            'answer': `Асинхронный ввод-вывод, предоставляемый asyncio, позволяет одновременно обрабатывать большое
                       количество запросов, не блокируя основной поток выполнения. В Django можно использовать asyncio
                       для обработки запросов, в работе которых требуется обращение к внешним сервисам, например, при
                       отправке электронной почты, обращении к API сторонних сервисов, работы с веб-сокетами и т.д.`},
        5: {'question': 'Многопроцессорность, многопоточность, асинхронность. В чём между ними разница и где что лучше использовать?',
            'answer': `Минусы многопроцессорности:<br>
                       - требуют много памяти (особенно для Python)<br>
                       - неэффективная коммуникация между процессами<br>
                       - overhead со стороны OS (user-space to kernel-space trip, scheduling, context switching),
                       тратится слишком много ресурсов, например вычищение кэшей при context switching<br>
                       <br>
                       Многопоточность имеет преимущества над многопроцессорностью:<br>
                       - требует меньше памяти<br>
                       - между потоками коммуникация более эффективная и простая чем между процессами (так как общая память)<br>
                       - менее ресурсозатратное переключение между потоками (не нужно чистить кэши)<br>
                       <br>
                       Но так же имеет ряд минусов:<br>
                       - иные проблемы с коммуникацией между потоками - состояние гонки, дедлоки (из-за общей памяти)<br>
                       - всё ещё overhead со стороны OS (шедулинг потоков)<br>
                       - даже если ограничивать количество потоков пулами, то пулы всё равно могут забиваться, приложение зависает<br>
                       `},
    },
    'databases': {
        1: {'question': 'Что такое ACID?', 'answer': 'databases answer 1'},
        2: {'question': 'Какими основными свойствами должна обладать транзакционная база данных?', 'answer': 'ACID'},
        3: {'question': 'Какое из свойств ACID является мнимым?', 'answer': '?'},
        4: {'question': 'Какие отличия есть между SQL и NoSQL базами данных?', 'answer': 'databases answer 3'},
        5: {'question': 'Какие существуют базы данных?',
            'answer': `SQL СУБД:<br>
                       - PostrgeSQL<br>
                       - MySQL<br>
                       - Microsoft SQL Server<br>
                       - Oracle Database<br>
                       - SQLite<br>
                       <br>
                       NoSQL СУБД:<br>
                       - MongoDB<br>
                       - ClickHouse<br>
                       <br>
                       Гибридные БД:<br>
                       - Redis<br>
                       - Tarantool<br>`},
        6: {'question': 'Что такое транзакция?', 'answer': 'databases answer 6'},
        7: {'question': 'Что такое индексы в базе данных? Зачем они нужны? Назовите плюсы и минусы индексации.',
            'answer': `Плюсы:<br>
                       - значительно ускоряют операции выборки и извлечения данных<br>
                       <br>
                       Минусы:<br>
                       - замедляют процессы обновления, добавления, вставки данных в базу, так как база требует обновления индексов<br>
                       - увеличивают размер базы данных, индексы занимают дополнительное место<br>
                       <br>
                       Индексировать следует лишь те поля, по которым точно будет производиться поиск, чтобы излишне не
                       замедлять базу и не увеличивать её размер.`},
        8: {'question': `Приходилось ли помимо ORM писать напрямую запросы к базе данных?
                         В каких случаях это требовалось?`,
            'answer': `Django ORM плохо оптимизирует JOIN запросы, в таких случаях приходится писать прямые SQL запросы к базе данных.`},
        9: {'question': 'Какие типы JOIN есть в SQL?',
            'answer': `- INNER JOIN<br>
                       - LEFT JOIN<br>
                       - RIGHT JOIN<br>
                       - FULL OUTER JOIN<br>
                       - CROSS JOIN<br>
                       - SELF JOIN<br>`},
        10: {'question': 'Есть две таблицы - на 10 и на 5 записей. Сколько записей станет при CROSS JOIN объединении? А при INNER JOIN?',
             'answer': 'При CROSS JOIN в объединённой таблице записей будет 50, а при INNER JOIN 10 или 5 записей.'},
        11: {'question': 'Что такое уровни изоляции?',
             'answer': `Это разграничение прав между параллельными транзакциями на доступ к общим ячейкам базы данных.
                        Выделяют 4 уровня изоляции:<br>
                        - Read Uncommitted (RU) - транзакция может читать данные, изменяемые другими незафиксированными
                        транзакциями, что может привести к чтению "грязных" данных<br>
                        - Read Committed (RC) - транзакция может читать только данные, зафиксированные в базе данных на
                        момент чтения или после, если данные были закоммичены<br>
                        - Repeatable Read (RR) - транзакция не будет видеть изменения, сделанные другими транзакциями
                        после начала чтения, что может привести к фантомным чтениям<br>
                        - Serializable (SE) - транзакции выполняются последовательно, что гарантирует изоляцию транзакций
                        и отсутствие фантомных чтений<br>`},
        12: {'question': 'Как в SQL-запросах использовать CTE, группировки, агрегации?',
             'answer': 'database answer 12'},
        13: {'question': 'В чём заключается проблема в ORM системах, которая называется N + 1?',
             'answer': `Проблема N+1 в ORM (Object-Relational Mapping) системах возникает, когда при доступе к связанным
                        объектам происходит большое количество запросов к базе данных, что может привести к неэффективности
                        и плохой производительности.<br>
                        <br>
                        N+1 означает, что основной запрос выполняется один раз для получения основных данных, а затем
                        для каждого полученного объекта выполняется дополнительный запрос для загрузки связанных данных.
                        Это может происходить, например, когда у вас есть сущность "Заказ" и каждый заказ имеет связь с
                        сущностью "Клиент". Если вы запрашиваете список заказов, а затем для каждого заказа отдельно
                        запрашиваете данные о клиенте, то возникает проблема N+1.

                        Проблема N+1 может приводить к следующим негативным эффектам:<br>
                        - избыточное количество запросов к базе данных, что может вызывать задержки и негативно влиять
                        на производительность вашего приложения<br>
                        - загрузка большого объема данных, которые могут не понадобиться<br>
                        - потеря преимуществ, которые могут предоставлять более эффективные запросы, объединяющие
                        связанные данные<br>
                        <br>
                        Одним из способов решения проблемы N+1 является использование механизмов предварительной
                        загрузки (eager loading), предоставляемых ORM системами. Предварительная загрузка позволяет
                        сделать единственный запрос, чтобы получить все необходимые данные, включая связанные объекты.`},
    },
    'algorithms': {
        1: {'question': 'Что такое Big O?', 'answer': 'algorithms answer 1'},
        2: {'question': 'algorithms question 2?', 'answer': 'algorithms answer 2'},
        3: {'question': 'Какая сложность у операции вставки в середину списка в Python?',
            'answer': `Вставка элемента в середину списка в Python занимает O(n) времени в худшем случае, где n - это
                       длина списка. Так как после вставки элемента необходимо перепривязать все соседние элементы, что
                       может потребовать прохождения до середины списка. Если индекс позиции вставки находится ближе к
                       началу списка, сложность может быть O(1) или близкой к этому значению.`},
        4: {'question': 'Какая сложность у операции вставки в конец списка в Python?',
            'answer': 'В Python сложность вставки в конец списка будет O(1), так как мы обращаемся по индексу.'},
        5: {'question': 'Какие алгоритмы сортировки существуют?', 'answer': 'Пузырьком, слиянием, быстрая сортировка/сортировка Хоара'},
        6: {'question': 'Что такое хэш-таблица?', 'answer': 'algorithms answer 6'},
        7: {'question': 'Как развернуть связный список (linked list)?', 'answer': 'algorithms answer 6'},
        8: {'question': 'Как развернуть словарь в Python?',
            'answer': `def reverse_dict(my_dict):<br>
                       <4s>current_node = my_dict<br>
                       <4s>new_pointer = None<br>
                       <4s>while current_node:<br>
                       <4s><4s>old_pointer = current_node['next']<br>
                       <4s><4s>current_node['next'] = new_pointer<br>
                       <4s><4s>new_pointer = current_node<br>
                       <4s><4s>current_node = old_pointer<br>
                       <4s>return new_pointer`},
    },
    'tests': {
        1: {'question': 'Какой процент кода нужно покрывать тестами?',
            'answer': `Нужно стремиться к 70-80%, но держать в голове, что на практике покрытие будет на 10-15% меньше, чем запланировал.`},
        2: {'question': 'Какие инструменты для тестирования существуют?',
            'answer': `- библиотека pytest<br>
                       - Postman для тестирования API<br>
                       - Selenium для автоматизации ручного тестирования<br>
                       - Linter для проверки Code Style`},
        3: {'question': 'Какие виды тестирования существуют в backend проектах на Python?',
            'answer': `- unit-тесты<br>
                       - интеграционные тесты<br>
                       - mock-тестирование`},
        4: {'question': 'Что такое unit-тесты? Зачем они нужны?',
            'answer': 'unit-тесты проверяют работоспособность отдельных модулей проекта'},
        5: {'question': 'Что такое интеграционные тесты? Зачем они нужны?',
            'answer': `answer 5`},
        6: {'question': 'Что такое mock-тесты? Зачем они нужны?',
            'answer': `answer 6`},
    },
    'oop': {
        1: {'question': 'Ссылки на материалы для изучения',
            'answer': `1) <a href="${links['oop'][0]}" target="_blank">Курс по ООП</a> от Сергея Балакирева<br>
                       2) Подробное объяснение <a href="${links['oop'][1]}" target="_blank">концепций SOLID</a><br>
                       3) Подробное объяснение <a href="${links['oop'][2]}" target="_blank">концепций ООП</a>`},
        2: {'question': 'Что такое SOLID?', 'answer': 'oop answer 1'},
        3: {'question': 'Какие основные концепции ООП? Опишите их.',
            'answer': `Основных концепций ООП 3: инкапсуляция, наследование и полиморфизм. Так же иногда отдельно
                       выделяют четвёртую концепцию - абстракция. В Python инкапсуляция присутствует, но с оговорками: в
                       Python отсутствует сокрытие реализации класса. Можно усложнить доступ к методам класса прописав
                       двойное подчёркивание в начале имени метода, но полной защиты это не даст.`},
        4: {'question': 'Что такое ромбовидное наследование?',
            'answer': `Ромбовидное наследование (diamond inheritance) - это специфика множественного наследования,
                       которая возникает, когда один класс наследуется от двух классов через промежуточный класс,
                       которые оба наследуют от одного и того же базового класса. Это создает структуру наследования в
                       форме ромба, где базовый класс расположен на вершине ромба, а наследующие классы - на боковых
                       сторонах.`},
        5: {'question': 'Что такое абстрактный класс?',
            'answer': `Абстрактный класс похож на интерфейс, но в отличии от интерфейса в абстрактном классе у методов
                       можно прописать реализацию. В Python в ядре языка нет реализации абстрактных классов,
                       однако с версии языка 2.6 в стандартную библиотеку добавлен модуль abc и абстрактный класс
                       можно создать путем наследования от класса abc.ABC из модуля abc и объявления абстрактных
                       методов с помощью декоратора @abstractmethod и абстрактных свойств с помощью декоратора
                       @abstractproperty.`},
        6: {'question': 'Что такое интерфейс?',
            'answer': `Интерфейс хранит описание методов с их параметрами без реализации, т.е. интерфейс не является
                       классом и для него нельзя создать объект. В Python нет интерфейсов, но есть концепция
                       "duck typing", которая позволяет проверять объекты на наличие нужных атрибутов и методов вместо
                       проверки типов данных. Это означает, что классы могут использоваться как интерфейсы, если они
                       предоставляют необходимый функционал.`},
        7: {'question': 'Как в Python указать модификатор private?',
            'answer': `В Python нет такого модификатора доступа, как private, как, например, в Java или C#. Вместо
                       этого в Python используется соглашение об именовании, которое гласит о том, что имя атрибута или
                       метода, начинающееся с одного символа подчеркивания, относится к категории protected и к нему можно
                       обращаться только внутри класса и его наследников, а имя атрибута или метода, начинающееся с двух
                       символов подчёркивания, относится к категории private и его можно использовать только внутри самого
                       класса. В случае с одним подчёркиванием это лишь соглашение на словах, т.е. фактически к таким
                       атрибутам и методам если захотим мы сможем без проблем обратиться, а вот в случае с двойным
                       подчёркиванием есть внутренний механизм в Python, который прячет такие атрибуты и методы, но так
                       же не на 100% - Python лишь усложняет к ним доступ - изменяет имя, по которому к ним можно обратиться.
                       Через функцию dir() можно вывести все методы и атрибуты класса и посмотреть какое имя Python присвоил
                       нашим private методам, через эти имена к ним и можно обращаться. Т.е. оба этих способа не являются
                       надёжной защитой от доступа к приватным свойствам/методам. Кстати, многие IDE подчёркивают как
                       ошибку обращение к таким атрибутам и методам, дополнительно сигнализируя программисту обратить
                       внимание что он нарушает правила.<br>
                       <br>
                       В Python есть возможность прописать внутри класса свои геттеры и сеттеры через декоратор @property:<br>
                       @property - в качестве getter<br>
                       @<атрибут>.setter - в качестве setter<br>
                       @<атрибут>.deleter - в качестве deleter<br>
                       С помощью этого механизма можно частично реализовать логику "private" доступа к атрибутам. Это
                       позволит скрыть от пользователя некоторые свойства и методы. Однако и этот способ не позволяет
                       полностью защититься от доступа за пределами класса (получить свойство и присвоить ему значение
                       можно через метод __dict__[name] = value), где name - имя свойства. Это скорее инструмент для
                       условной защиты свойств класса.<br>
                       Пример реализации:<br>
                       class MyClass:<br>
                       <4s>def __init__(self, val):<br>
                       <4s><4s>self._val = val<br>
                       <br><br>
                       <4s>@property<br>
                       <4s>def val(self):<br>
                       <4s><4s>print("Getting val")<br>
                       <4s><4s>return self._val<br>
                       <br><br>
                       <4s>@val.setter<br>
                       <4s>def val(self, value):<br>
                       <4s><4s>print("Setting val")<br>
                       <4s><4s>self._val = value<br>
                       <br><br>
                       <4s>@val.deleter<br>
                       <4s>def val(self):<br>
                       <4s><4s>print("Deleting val")<br>
                       <4s><4s>del self._val<br>
                       <br>
                       Однако всё же есть способ жёстко ограничить доступ к атрибутам и методам в классе - с помощью
                       библиотеки accessify. Она предоставляет декораторы @private и @protected, которые можно прописать
                       к нужному методу или атрибуту класса и тогда они получат реальный уровень доступа private или
                       protected и к ним нельзя будет обратиться извне.<br>`},
        8: {'question': 'Как проверить, что элемент является экземпляром класса в Python?',
            'answer': 'isinstance(my_element, TargetClass)'},
        9: {'question': 'Какие магические методы есть у классов в Python?',
            'answer': `1) __new__<br>
                       2) __init__<br>
                       3) __del__<br>
                       4) __call__ - автоматически вызывается при вызове класса (когда мы пишем имя класса и далее
                       круглые скобки). Если определить этот метод в экземпляре класса, то он будет срабатывать каждый
                       раз при вызове экземпляра класса с круглыми скобками (такие классы называются функторами).<br>
                       5) __str__ - служит для отображения информации об объекте класса для функций print, str<br>
                       6) __getattr__(self, name) в Python - это метод специального имени (special method), который
                       вызывается в случае, если атрибут, на который происходит обращение, отсутствует в экземпляре
                       класса. Если определить в классе метод __getattr__(name), то при попытке обратиться к
                       несуществующему атрибуту будет вызван именно этот метод.<br>
                       7) __setattr__(self, key, value) - автоматически вызывается при изменении свойства key класса<br>
                       8) __delattr__(self, item) - автоматически вызывается при удалении свойства item (не важно существует оно или нет)<br>
                       9) __getattribute__(self, item) - автоматически вызывается при получении свойства класса с именем item<br>
                       10) __dict__<br>
                       11) __set_name__ (у дескрипторов)<br>
                       12) __set__ (у дескрипторов)<br>
                       13) __get__ (у дескрипторов)<br>
                       14) __repr__ - служит для отображения информации об объекте класса в режиме отладки (для разработчиков).
                       Вызывается, когда мы пишем в консоли имя экземпляра класса без каких либо функций.
                       Если в классе не определён метод __str__, то так же будет вызываться функциями print и str<br>
                       15) __len__ - вызывается при передачи экземпляра класса в функцию len()<br>
                       16) __abs__ - вызывается при передачи экземпляра класса в функцию abs()<br>
                       17) __add__ - вызывается при применении к экземпляру класса оператора сложения (справа от него).
                       Так же есть аналогичный метод __radd__, который так же вызывается при применении к экземпляру
                       класса оператора сложения, но слева от него. Ещё есть аналогичный метод __iadd__, который вызывается
                       при применении слева от экземпляра класса оператора += (если уже определён метод __add__, то
                       операция += выполнится и без __iadd__, но в таком случае мы создадим лишний экземпляр класса,
                       отдельный метод __iadd__ позволяет этого избежать)<br>
                       18) __sub__ - вызывается при применении к экземпляру класса оператора вычитания. По аналогии с
                       методом __add__ есть так же методы __rsub__ и __isub__.<br>
                       19) __mul__ - вызывается при применении к экземпляру класса оператора умножения. По аналогии с
                       методом __add__ есть так же методы __rmul__ и __imul__.<br>
                       20) __truediv__ - вызывается при применении к экземпляру класса оператора целочисленного деления.
                       По аналогии с методом __add__ есть так же методы __rtruediv__ и __itruediv__.<br>
                       21) __floordiv__ - вызывается при применении к экземпляру класса оператора деления со знаками
                       после запятой. По аналогии с методом __add__ есть так же методы __rfloordiv__ и __ifloordiv__.<br>
                       22) __mod__ - вызывается при применении к экземпляру класса оператора деления по модулю (взятие
                       остатка от деления). По аналогии с методом __add__ есть так же методы __rmod__ и __imod__.<br>
                       23) __eq__ - вызывается при применении к экземпляру класса оператора ==, т.е. при проверке на
                       равенство. Если метод не определён в классе, то по умолчанию сравнивать будет id экземпляра класса.<br>
                       24) __ne__ - вызывается при применении к экземпляру класса оператора !=, т.е. при проверке на
                       неравенство. Если метод не определён в классе, но уже определён метод __eq__, то вызовет его и
                       инвертирует результат (вернёт обратный результат).<br>
                       25) __lt__ - вызывается при применении к экземпляру класса оператора <. Если метод не определён в
                       классе, но уже определён метод __gt__, то вызовет его и инвертирует результат (вернёт обратный результат).<br>
                       26) __le__ - вызывается при применении к экземпляру класса оператора <=. Если метод не определён в
                       классе, но уже определён метод __ge__, то вызовет его и инвертирует результат (вернёт обратный результат).<br>
                       27) __gt__ - вызывается при применении к экземпляру класса оператора >. Если метод не определён в
                       классе, но уже определён метод __lt__, то вызовет его и инвертирует результат (вернёт обратный результат).<br>
                       28) __ge__ - вызывается при применении к экземпляру класса оператора >=. Если метод не определён
                       в классе, но уже определён метод __le__, то вызовет его и инвертирует результат (вернёт обратный результат).<br>
                       29) __hash__ - вызывается при вычислении хэша объекта класса.<br>
                       30) __bool__ - вызывается при проверке объекта класса на булевый тип (True/False). По умолчанию
                       любой экземпляр класса при проверке на булевый тип вернёт True. Можно самим определить метод
                       __bool__, тогда он вернёт результат нашей прописанной логики. Важно - результатом должно быть
                       значение True или False, иначе выдаст ошибку. Так же есть исключение - если в классе не определён
                       метод __bool__, но определён метод __len__, тогда при проверке на булевый тип будет вызван метод
                       __len__, причём в отличии от метода __bool__ он возвращает числовые значения, следовательно если
                       число будет 0, тогда это будет False, а любое другое число будет True.<br>
                       31) __getitem__ - вызывается при обращении к экземпляру класса по индексу. Например myObject[2],
                       где myObject это экземпляр класса. Для такого случая нужно определить метод __getitem__(self, index),
                       в который будет передан индекс и мы реализуем логику обращения к какому-либо итерируемому свойству
                       нашего класса и вернём результат.<br>
                       32) __setitem__ - вызывается при присвоении значения экземпляру класса по индексу. Например
                       myObject[2] = 5, где myObject это экземпляр класса. Для такого случая нужно определить метод
                       __setitem__(self, index, value), в который будет передан индекс и новое значение и мы реализуем
                       логику присвоения нового значения какому-либо итерируемому свойству класса.<br>
                       33) __delitem__ - вызывается при применении оператора del при обращении к экземпляру класса по
                       индексу. Например del myObject[2], где myObject это экземпляр класса. Для такого случая нужно
                       определить метод __delitem__(self, index), в который будет передан индекс и мы реализуем логику
                       удаления элемента из какого-либо итерируемого свойства класса.<br>
                       34) __iter__ - вызывается при передаче экземпляра класса в функцию iter(). Например, если у нас
                       есть объект myObject и мы реализуем цикл for item in myObject, то будет неявно вызвана функция
                       iter() и в неё будет передан объект myObject. В таком случае у объекта будет вызван метод __iter__
                       с реализованной нами логикой, а если метод не определён, то произойдёт ошибка.<br>
                       35) __next__ - вызывается при передаче объекта класса в функцию next().<br>`},
        10: {'question': 'Как получить все свойства класса в Python?',
            'answer': `Можно использовать функцию dir(), которая вернёт все свойства и методы класса, а затем
                       исключить методы. Например, так можно реализовать метод, обнуляющий все свойства в классе:<br>
                       def reset(self):<br>
                       <4s>for attr in dir(self):<br>
                       <4s><4s>if not callable(getattr(self, attr)) and not attr.startswith("__"):<br>
                       <4s><4s><4s>setattr(self, attr, None)`},
        11: {'question': 'Что такое "магические методы" в классах Python?',
             'answer': `Это методы по умолчанию, которые есть у любого класса при его создании, имена таких методов
                        начинаются и заканчиваются двойным нижним подчёркивание.`},
        12: {'question': 'Какие типы методов есть в классах Python?',
             'answer': `В классах Python есть 3 типа методов. Например:<br>
                        class MyClass:<br>
                            <4s>GLOBAL_ARG = 100<br><br>

                            <4s>def __init__(self, x, y):<br>
                                <4s><4s>self.x = x<br>
                                <4s><4s>self.y = y<br><br>

                            <4s>def first_method(self, arg1, arg2):<br>
                                <4s><4s>print(arg1 * x + arg2 * y)<br>
                                <4s><4s>self.x = arg1<br>
                                <4s><4s>self.y = arg2<br><br>

                            <4s>@classmethod<br>
                            <4s>def second_method(cls, arg):<br>
                                <4s><4s>print(cls.GLOBAL_ARG * arg)<br>
                                <4s><4s>cls.GLOBAL_ARG = arg<br><br>

                            <4s>@staticmethod<br>
                            <4s>def third_method(arg1, arg2):<br>
                                <4s><4s>print(arg1 * arg2)<br><br>

                        1) first_method - это тип метода по умолчанию, который принимает в качестве обязательного
                        аргумента экземпляр класса через ключевое слово self (в неявном виде) и лишь через него
                        происходит обращение к методу. В таком методе мы можем обращаться к свойствам экземпляра класса.<br>
                        - my_instance = MyClass(1, 2)<br>
                        &nbsp;&nbsp;my_instance.first_method(3, 4) или MyClass(my_instance).first_method(3, 4), что
                        эквивалентно друг другу.<br> В данном примере выполнится код print(1 * 3 + 2 * 4) и в консоль
                        будет выведено число 11, а затем мы изменяем свойства созданного класса x и y на переданные в
                        метод два аргумента.<br><br>
                        2) second_method - тип метода самого класса, где не требуется иметь готовый экземпляр класса
                        для обращения к методу, обращение к методу идёт через обращение к самому классу. Данный тип
                        метода объявляется через декоратор @classmethod. Принимает обязательный аргумент - сам класс
                        через ключевое слово cls (в неявном виде). В таком методе мы можем обращаться к свойствам самого
                        класса, которые являются общими для всех экземпляров класса:<br>
                        - MyClass.second_method(5)<br>
                        В данном примере выполнится код print(100 * 5) и в консоль будет выведено число 500, а затем мы
                        изменяем общее свойство нашего класса GLOBAL_ARG на переданный в метод аргумент.<br><br>
                        3) third_method - статический тип метода, который не имеет обязательных аргументов. Данный тип
                        метода объявляется через декоратор @staticmethod. По сути является полным аналогом обычной функции,
                        только упакованной в класс для удобства, например для объединения функций по тематикам класса.
                        Может иметь доступ к экземпляру класса или объекту самого класса, если их передать в него в виде
                        опциональных аргументов (если заранее их объявили в методе).<br>
                        - MyClass.third_method(7, 8)<br>
                        В данном примере выполнится код print(7 * 8) и в консоль будет выведено число 56.<br>
                        Метод не умеет по умолчанию принимать экземпляр класса или объект самого класса, но их можно
                        передать явно (объявив заранее в методе как обычные аргументы) и точно так же взаимодействовать
                        с ними, изменять их. Например можно реализовать статический метод, который явно принимает
                        экземпляр класса и объект класса (остальной код класса как в первом примере):<br>
                        @staticmethod<br>
                        def third_method(arg1, arg2, arg3, cls_arg, self_arg):<br>
                            <4s>print(arg1, arg2, self_arg.x, self_arg.y, cls_arg.GLOBAL_ARG)<br>
                            <4s>self_arg.x = arg1<br>
                            <4s>self_arg.y = arg2<br>
                            <4s>cls_arg.GLOBAL_ARG = arg3<br>
                        <br>
                        my_instance = MyClass(1, 2)<br>
                        MyClass.third_method(9, 3, MyClass, my_instance)<br>
                        <br>
                        В данном примере мы создали экземпляр класса, затем вызвали статический метод и явно передали в
                        него экземпляр класса и объект самого класса  и ещё три числа. В результате выполнился код
                        print(9, 3, 1, 2, 100), а далее мы присвоили свойствам экземпляра класса и глобальному свойству
                        класса значения переданных числовых аргументов.
                        `},
        13: {'question': 'Что такое атрибуты класса в Python?',
             'answer': 'Атрибутами класса называют свойства (переменные) и методы (функции) класса.'},
        14: {'question': 'Как получить все атрибуты класса в Python?',
             'answer': `Можно использовать функцию dir(), которая в качестве аргумента принимает экземпляр класса и
                        возвращает всего его методы и свойства.`},
        15: {'question': 'В чём отличие уровней доступа private и protected?',
             'answer': `private разрешает доступ только в внутри самого класса, а protected внутри класса и его
                        наследников. Но они оба запрещают доступ извне к защищённому свойству/методу извне класса.`},
        16: {'question': 'Что такое дескриптор в Python?',
             'answer': `Дескриптор в Python - это объект, который может определять, как должны работать операции доступа
                        к атрибутам класса. Он позволяет настраивать поведение чтения, записи и удаления атрибутов
                        объекта. Если у каких то свойств нашего класса должны быть одинаковые методы доступа, дескрипторы
                        позволяют сделать единый шаблон, избавляя от необходимости каждому свойству класса прописывать
                        методы доступа по отдельности, что загромождало бы код. Таким образом дескрипторы позволяют гибко
                        управлять доступом к атрибутам класса, делают код более читаемым и модульным. Например:<br>
                        class Descriptor:<br>
                        <4s>def __get__(self, instance, owner):<br>
                        <4s><4s># Логика чтения значения атрибута<br>
                        <4s><4s>pass<br>
                        <br>
                        <4s>def __set__(self, instance, value):<br>
                        <4s><4s># Логика записи значения атрибута<br>
                        <4s><4s>pass<br>
                        <br>
                        <4s>def __delete__(self, instance):<br>
                        <4s><4s># Логика удаления атрибута<br>
                        <4s><4s>pass<br>
                        <br>
                        class MyClass:<br>
                        <4s>attribute_one = Descriptor()<br>
                        <4s>attribute_two = Descriptor()<br>
                        <br>
                        В этом примере класс Descriptor является дескриптором, а класс MyClass содержит атрибут attribute_one
                        и attribute_two, которые будет обрабатываться с помощью этого дескриптора.`},
        17: {'question': 'Что такое функторы в Python?',
             'answer': `Функторы в Python - это объекты, которые могут быть вызваны (т.е. имеют метод __call__), и при
                        вызове они выполняют некоторое действие или возвращают значение. Например функция или класс -
                        это функторы. Экземпляр класса так же можно сделать функтором, если прописать для него метод
                        __call__.`},
        18: {'question': 'Как в Python внутри класса обратиться к самому классу без упоминания имени?',
             'answer': `В Python внутри класса рекомендуется обращаться к самому классу без упоминания его имени, потому
                        что в процессе разработке название класса может измениться и придётся вносить изменения по всему
                        коду. Этого можно избежать, если обращаться к классу через self.__class__. Например если внутри
                        класса мы пишем метод, который должен возвращать новый экземпляр класса, то вместо MyClass(value)
                        можно прописать self.__class__(value) - выглядит страшнее, но это более гибкое решение, которое
                        избавляет нас от привязки к имени класса.`},
        19: {'question': 'Какие принципы SOLID можно соблюсти в Python?',
             'answer': `oop answer 19`},
    },
    'django': {
        1: {'question': 'Что нового в версиях Django 2.x/3.x/4.x?',
            'answer': `Версия 3.0 (2 дек 2019):<br>
                       - добавлена поддержка MariaDB, ASGI<br>
                       Версия 3.1 (4 авг 2020):<br>
                       - добавлена поддержка асинхронных view и middleware<br>
                       Версия 4.1 (3 авг 2022):<br>
                       - добавлен асинхронный интерфейс к ORM`},
        2: {'question': 'Что такое миграции в Django?',
            'answer': `Миграции баз данных в Django - это способ управления изменениями в структуре базы данных в процессе
                       разработки приложений. Миграции позволяют автоматически применять изменения, сделанные в коде
                       приложения, к уже существующей базе данных. В Django создание миграций начинается с команды
                        makemigrations, которая создает файлы миграций на основе моделей приложения, в эти файлы записываются
                       все изменения в структуре базы данных, которые вы внесли. Затем эти миграции применяются к базе
                       данных с помощью команды migrate. Такой подход помогает разработчикам безопасно и эффективно
                       изменять структуру базы данных, минимизируя время простоя.<br>
                       <br>
                       Механизм:<br>
                       1) Захотели изменить таблицу в базе (добавить столбцы, удалить столбцы, изменить тип полей)<br>
                       2) Вносите изменение в класс, описывающий таблицу в файле models.py<br>
                       3) Выполняете команду manage.py makemigrations, которая создаст sql-запросы к базе данных,
                       нужные для изменения структуры базы данных как вы хотите<br>
                       4) Выполняете команду manage.py migrate, которая выполнит все сгенерированные sql-запросы, либо
                       выдаст ошибку в случае конфликта<br>
                       <br>
                       Файлы миграций хранят историю изменения базы данных, используя их можно откатиться до предыдущего
                       состояния базы данных.`},
        3: {'question': 'Что такое модели в Django?', 'answer': 'django answer 3'},
        4: {'question': 'Что такое prefetch_related и select_related в Django?',
            'answer': `select_related и prefetch_related - это методы оптимизации запросов в Django ORM для связей между
                       таблицами в базе данных.<br>
                       <br>
                       select_related используется для сокращения количества SQL-запросов при доступе к связанным объектам
                       по внешним ключам, делая JOIN с предварительной выборкой связанных объектов. Удобен при работе с
                       одним-ко-многим или один-к-одному отношению.<br>
                       <br>
                       prefetch_related позволяет избежать дополнительных запросов при доступе к QuerySet'у, имеющему
                       связанные объекты в виде множества. Он работает путем выполнения двух отдельных запросов к базе
                       данных - один для исходного QuerySet'а и один для заполнения кэша со всеми связанными объектами.
                       Запрос к базе данных заполняет кэш, а затем django загружает все связанные объекты из кэша вместо
                       выполнения дополнительных запросов впоследствии. Таким образом, в отличие от select_related,
                       prefetch_related особенно полезен, когда QuerySet имеет связанные объекты в виде множества, т.е.
                       имеет связь многие-ко-многим.`},
        5: {'question': 'Что такое ленивые запросы (lazy queries) в Django?',
            'answer': `Ленивые запросы (lazy queries) в Django - это объекты QuerySet, которые не выполняются сразу, а
                       только при обращении к результату запроса. Таким образом, вместо выполнения запроса к базе данных
                       сразу после создания QuerySet'а, Django откладывает выполнение запроса до момента, когда это
                       действительно необходимо (например, при доступе к первому элементу запроса). Это позволяет избежать
                       выполнения лишних запросов в случае, когда результат запроса в итоге не будет использован.`},
        6: {'question': 'Что такое QuerySet в Django?',
            'answer': `Объект QuerySet в Django используется для описания запроса к базе данных. Когда мы присваиваем
                       переменной значение из базы данных, то фактически в переменную записывается объект QuerySet,
                       который мы описали, например my_value = MyModel.objects.filter(type='string'). Само значение
                       запишется в переменную только после того, как мы обратимся к этой переменной, т.е. выполнится
                       отложенный запрос к базе данных. Примеры вопросов с техсобесов:<br>
                       1) Сколько запросов к базе данных будет выполнено в этом коде:<br>
                       a = MyModel.objects.all()<br>
                       2) Сколько запросов к базе данных будет выполнено в этой функции?<br>
                       def test():<br>
                       <4s>MyModel.object.filter(type="a")<br>
                       <4s>MyModel.object.filter(type="b")<br>
                       <4s>c = MyModel.object.filter(type="c")<br>
                       <br>
                       На оба вопроса правильный ответ - ноль, так как мы лишь описали запросы к базе данных, выполнятся
                       они лишь когда мы обратимся к тем переменным, в которые их записали.`},
        7: {'question': 'Как в Django написать прямой запрос к базе данных (например Postgres)?',
            'answer': `import psycopg2
                       <br><br>
                       conn = psycopg2.connect(database="mydatabase", user="mydatabaseuser", password="mypassword", host="localhost", port="5432")
                       <br><br>
                       cur = conn.cursor()
                       <br><br>
                       cur.execute("SELECT * FROM mytable")
                       <br><br>
                       conn.close()`},
        8: {'question': 'Как параметры есть у полей в ORM Django?',
            'answer': `- verbose_name<br>
                       - default<br>
                       - unique (так же unique_for_date, unique_for_month, unique_for_year)<br>
                       - null<br>
                       - blank<br>
                       - db_index<br>
                       - primary_key<br>
                       - editable<br>
                       - db_column`},
        9: {'question': 'Чем поле TextField отличается от CharField в ORM Django?',
            'answer': `django answer 9`},
        10: {'question': 'Опишите принцип работы связей ForeignKey, OneToOneField и ManyToManyField в ORM Django.',
            'answer': `django answer 10`},
        11: {'question': 'Что такое сигналы Django?',
            'answer': `django answer 11`},
        12: {'question': 'Опишите структуру Django проекта - файлы, папки.',
            'answer': `django answer 12`},
        13: {'question': 'Какими недостатками обладает Django?',
            'answer': `Django монолитный, от него сложно оторвать его модули. Например Django ORM, который пронизывает
                       всю систему, из-за этого ему сложно даётся асинхронность. Так же template движок (движок шаблонов),
                       от которого с трудом можно избавиться, но вы потеряете при этом часть функциональности. Таким
                       образом Django хорош в определённых сферах применения.`},
    },
    'git': {
        1: {'question': 'В чём отличие merge от rebase?',
            'answer': `Отличие между rebase и merge в Git заключается в том, как происходит объединение изменений из
                       разных веток в одну. Merge создает новый коммит, который имеет двух предков - последний коммит в
                       текущей ветке и последний коммит в объединяемой ветке. Rebase же перемещает все изменения из
                       текущей ветки на вершину целевой ветки, что позволяет создать линейную историю коммитов без
                       ветвлений и точек слияния. Это полезно, если вы хотите иметь чистую, простую историю коммитов в
                       ветке, или если вы работаете над веткой, которая долгое время не была обновлена и может содержать
                       конфликты с последней версией целевой ветки.`},
        2: {'question': 'Какие команды git вы использовали в работе?',
            'answer': `- git clone<br>
                       - git add<br>
                       - git commit<br>
                       - git push<br>
                       - git pull<br>
                       - git rebase<br>
                       - git merge<br>
                       - git amend<br>`},
        3: {'question': 'Что такое gitignore и зачем он нужен?',
            'answer': `git answer 3`},
    },
    'docker': {
        1: {'question': `Что такое Docker и Docker Compose? Зачем они нужны?`,
            'answer': `answer docker 1`},
        2: {'question': `В чём разница при написании Dockerfile в двух этих примерах?<br>
                         1) RUN apk add --no-cache git gcc g++ libffi-dev musl-dev postgresql-client postgresql-dev
                         zlib-dev pcre pcre-dev build-base && pip install --no-cache-dir -r requirements.txt && apk del
                         git gcc g++ libffi-dev musl-dev postgresql-dev zlib-dev pcre-dev build-base<br>
                         2) RUN apk add --no-cache git gcc g++ libffi-dev musl-dev postgresql-client postgresql-dev
                         zlib-dev pcre pcre-dev build-base RUN pip install --no-cache-dir -r requirements.txt
                         RUN apk del git gcc g++ libffi-dev musl-dev postgresql-dev zlib-dev pcre-dev build-base`,
             'answer': `Первый Dockerfile выполняет установку требуемых зависимостей с помощью команды RUN одним сложным
                        шагом. Это делается для оптимизации работы Docker, чтобы уменьшить количество слоев образа и
                        уменьшить их размер. Второй Dockerfile разбивает установку на несколько шагов, каждый из которых
                        создает свой слой Docker. Это делается для упрощения сборки и отладки Docker-образа, так как
                        каждый слой Docker может быть переиспользован при последующих сборках.`},
        3: {'question': 'Каковы основные преимущества использования Docker по сравнению с традиционными виртуальными машинами?',
            'answer': 'drf answer 3'},
        4: {'question': 'Как можно оптимизировать Docker-образы, чтобы уменьшить их размер?',
            'answer': 'drf answer 4'},
        5: {'question': 'Какие команды Docker вы знаете и как они используются?',
            'answer': 'drf answer 5'},
        6: {'question': 'Как Docker гарантирует изоляцию приложений в контейнерах?',
            'answer': 'drf answer 6'},
        7: {'question': 'Как выполняется сетевое взаимодействие между Docker-контейнерами и между контейнером и хостовой машиной?',
            'answer': 'drf answer 7'},
        8: {'question': 'Как использовать Docker Compose для управления множеством контейнеров и их зависимостей?',
            'answer': 'drf answer 8'},
        9: {'question': 'Как обновлять и масштабировать контейнеры Docker на живом сайте без прерывания работы приложения?',
            'answer': 'drf answer 9'},
        10: {'question': 'Какими инструментами вы пользуетесь для мониторинга и логгирования контейнеров Docker?',
            'answer': 'drf answer 10'},
        11: {'question': 'Как обеспечить безопасность при использовании Docker и минимизировать потенциальные уязвимости?',
            'answer': 'drf answer 11'},

    },
    'drf': {
        1: {'question': 'Что такое сериализаторы в DRF?', 'answer': 'drf answer 1'},
        2: {'question': 'Как в DRF настраивается роутинг URL?',
            'answer': `Пример создания роутеров для методов /departments и /employees в файле urls.py:<br>
                       from django.urls import include, path<br>
                       from rest_framework import routers<br>
                       from .views import DepartmentViewSet, EmployeeViewSet<br>
                       <br>
                       router = routers.DefaultRouter()<br>
                       router.register(r'departments', DepartmentViewSet)<br>
                       router.register(r'employees', EmployeeViewSet)<br>
                       <br>
                       urlpatterns = [<br>
                       <4s>path('', include(router.urls)),<br>
                       ]`},
        3: {'question': 'Как сделать разграничение прав для API метода в DRF?',
            'answer':
            `Для этого в класс-представление нужно добавить поле permission_classes = [] и в нём указать каким группам
             разрешено использовать данный API метод. Например:<br>
             permission_classes = [IsAuthenticated, IsAuthenticatedOrReadOnly]`},
        4: {'question': 'Какие уровни разграничения прав к API методам есть в DRF?',
            'answer': `- IsAuthenticated<br>
                       - IsAuthenticatedOrReadOnly<br>
                       - ?`},
        5: {'question': 'Что такое встроенные DRF фильтры?',
            'answer': `Встроенные DRF фильтры - это набор классов фильтров, предоставляемых Django REST Framework "из коробки"
                       для фильтрации queryset'ов в представлениях API. Список фильтров:<br>
                       - DjangoFilterBackend<br>
                       - SearchFilter<br>
                       - OrderingFilter<br>
                       - Pagination`},
        6: {'question': 'Как в DRF добавить свой API метод с помощью ViewSet?',
            'answer': `Для этого можно использовать декоратор @action, он позволяет добавить кастомные методы к вашему
                       ViewSet.<br>
                       1) Определите свой метод внутри класса ViewSet, добавив декоратор @action перед его определением.<br>
                       2) Укажите тип метода (например, GET, POST и т. д.) в качестве параметра detail декоратора @action.<br>
                       3) Определите URL-шаблон для вашего метода, передав шаблон в качестве параметра url_path декоратора @action.<br>
                       <br>
                       `},
        7: {'question': 'Как в DRF посмотреть все API методы?',
            'answer': `Запустить локальный сервер и в адресной строке набрать 127.0.0.1:8000/api/`},
        8: {'question': 'Что такое Generics в DRF?',
            'answer': 'drf answer 8'},
        9: {'question': 'Что такое ModelViewSet в DRF? Что он в себя включает?',
            'answer': 'drf answer 9'},
    },
    'brokers': {
        1: {'question': 'Зачем нужны брокеры сообщений?', 'answer': 'brokers answer 1'},
        2: {'question': 'Как устроен RabbitMQ?', 'answer': 'brokers answer 2'},
        3: {'question': 'Как устроен Kafka?', 'answer': 'brokers answer 3'},
        4: {'question': 'В чём принципиальное отличие между RabbitMQ и Kafka?', 'answer': 'brokers answer 4'},
    },
    'other': {
        1: {'question': 'Ссылки на материалы для изучения',
            'answer': `1) <a href="https://yourwaytoit.ru/termins/Backend/Общее/first/" target="_blank">Термины Backend</a>`},
        2: {'question': 'Что такое REST?', 'answer': 'other answer 1'},
        3: {'question': 'Что такое KISS?', 'answer': 'other answer 2'},
        4: {'question': 'Что такое DRY?', 'answer': 'other answer 3'},
        5: {'question': 'Что такое вебсокеты?', 'answer': 'other answer 4'},
        6: {'question': 'Что такое монолит и микросервисы?', 'answer': 'other answer 5'},
        7: {'question': 'Как вы изучали программирование?', 'answer': 'other answer 6'},
        8: {'question': 'Какие существуют инструменты для оптимизации кода в Django проектах?',
            'answer': `cProfile - это модуль Python, который позволяет профилировать код на уровне функций и строк кода.<br><br>
                       line_profiler - это модуль для профилирования производительности на уровне строк кода.<br><br>
                       Django Debug Toolbar - это инструмент для отслеживания производительности Django-приложений.<br><br>
                       ISort - это утилита / библиотека на Python для сортировки импортируемых модулей в алфавитном
                       порядке, автоматического разделения их на секции, а также группировки по типу.`},
        9: {'question': 'Какие паттерны программирования вы знаете?',
            'answer': `1) Декоратор - паттерн присущий языку Python<br>
                       2) Singleton - в некоторых языках есть из коробки, но в Python его можно реализовать самостоятельно:<br>
                       class Singleton:<br>
                       <4s>__instance = None<br>
                       <br>
                       <4s>def __new__(cls):<br>
                       <4s><4s>if cls.__instance is None:<br>
                       <4s><4s><4s>cls.__instance = object.__new__(cls)<br>
                       <4s><4s>return cls.__instance<br>
                       3) Наследование<br>
                       4) Моносостояние - реализация общего пространства имён для экземпляров класса.
                       Пример реализации на Python:<br>
                       class ThreadData:<br>
                       <4s>__shared_attrs__ = {<br>
                       <4s><4s>'name': 'thread_1',<br>
                       <4s><4s>'data': {},<br>
                       <4s><4s>'id': 1<br>
                       <4s>}<br>
                       <br>
                       <4s>def __init__(self):<br>
                       <4s><4s>self.__dict__ = self.__shared_attrs`},
        10: {'question': 'Что такое замыкание?',
             'answer': `Замыкание - это концепция, которая существует во многих языках программирования и позволяет
                        функции запоминать и использовать переменные из своей объемлющей области видимости даже после
                        того, как эта область видимости уже неактивна. Например:
                        def outer_function(x):<br>
                        <4s>def inner_function(y):<br>
                        <4s><4s>return x + y<br>
                        <br>
                        <4s>return inner_function<br>
                        <br>
                        <br>
                        closure = outer_function(10)<br>
                        result_1 = closure(5)<br>
                        result_2 =  closure(10)<br>
                        print(result_1, result_2)<br>
                        <br>
                        В консоль будет выведено:<br>
                        15<br>
                        20<br>
                        <br>
                        Так происходит потому, что переменная closure хранит ссылку на функцию inner_function, которая в
                        свою очередь обращается к переменной x, т.е. имеет неявную скрытую ссылку на своё глобальное
                        окружение (на локальное окружение родительской функции outer_function, которое мы создали
                        при её вызове). Таким образом, так как имеется ссылочная связь по цепочке, то сборщик мусора не
                        удаляет переменную x.`},
    },
    'linux': {
        1: {'question': 'Какие основные команды есть в Linux?', 'answer': 'linux answer 1'},
        2: {'question': `Если в оперативной памяти 6 гигабайт, а процесс занимает 4 гигабайта и мы делаем форк процесса,
                         то что произойдёт?`,
            'answer': 'linux answer 2'},
        3: {'question': 'Как посмотреть все процессы?', 'answer': 'linux answer 3'},
    },
    'review': {
        1: {'question': `Проведите ревью кода<br><br>
                         class MyClass:<br>
                         <4s>def __init__(self, x, y):<br>
                         <4s><4s>self.x = x<br>
                         <4s><4s>self.y = y<br>
                         <br>
                         <4s>def __setattr__(self, key, value):<br>
                         <4s><4s>if key == x:<br>
                         <4s><4s><4s>raise AttributeError("недопустимое имя атрибута")<br>
                         <4s><4s>else:<br>
                         <4s><4s><4s>self.key = value<br>`,
            'answer': `В __setattr__ в случае else мы попадаем в рекурсию, так как будем каждый раз вызывать __setattr__.
                       Чтобы этого избежать нужно заменить строчку self.key = value на object.__setattr__(self, key, value)
                       (так же есть вариант self.__dict__[key] = value)`},
        2: {'question': 'второй пример', 'answer': 'ревью второго примера'},
    },
}

var mainText = `
    Совет №1: если крутите опыт, то очень хорошо проработайте легенду, посмотрите телеграм-канал "Один день ITшника",
    поспрашивайте опытных товарищей.
    <br><br>
    Совет №2: чем учить теорию до бесконечности выучите поверхностно любой список вопросов из интернета (топ 50 вопросов
    по вашему языку, топ 50 вопросов по вашему фреймворку) и идите практиковаться проходить собесы. За 5-6 собесов
    поймёте, что спрашивают 20-30 одних и тех же вопросов, выпишите их все и те что не знаете выучите.
    <br><br>
    Совет №3: включайте запись с экрана когда проходите техническое собеседование. Телефонные созвоны с эйчарами
    тоже желательно записывать. Потом отсматривайте/отслушивайте, выписывайте вопросы что задают, обращайте
    внимание как вы сами отвечаете, корректируйте свои ответы. Найдите оптимальный темп ответа: слишком быстрые
    ответы будут выглядеть как заученные, при слишком долгих размышлениях будете выглядеть неуверенно. Идеально
    знать ответ на вопрос и делать вид, что слегка задумался, а потом постепенно выдавать ответ, будто вспоминаешь.
    Ещё одна хитрость - старайтесь растягивать ответ, можно уйти в рассуждения, углубить ответ, затронуть другие темы,
    скорее всего собеседующий вас сразу же не прервёт и вы выиграете драгоценное время, ведь нам важно, чтобы за
    собеседование нам задали как можно меньше вопросов, а собеседование не резиновое.
    <br><br>
    Совет №4: на скрининге помимо общих вопросов эйчары могут поспрашивать технические вопросы по бумажке, либо
    тест с вариантами ответов, нужно быть к этому готовым. Твои ответы будут оценивать не они, они запишут ответы
    либо текстом, либо на аудио.
    <br><br>
    Совет №5: не ставьте на один день больше 2 технических собеседований, лучше вообще 1. Скринингов это не касается,
    можно и 5 штук поставить.
    <br><br>
    Совет №6: обязательно просить фидбек в конце интервью, даже если чувствуешь, что провалил его. Если после
    эйчар напишет отказ без фидбека тоже попросить обратную связь. Если всё же не получишь обратную связь, то не
    стоит загоняться по поводу причины отказа, причины могут быть совершенно разные:<br>
    - недостаточные знания<br>
    - не устроила причина твоего увольнения с последнего места работы<br>
    - в резюме слишком частые смены работ<br>
    - вакансия уже закрылась (хотя эту причину обычно озвучивают)<br>
    - ты попросил слишком много денег<br>
    - не понравилась твоя внешность<br>
    - не понравилась твоя манера общения<br>
    - не понравились твои взгляды на работу<br>
    - не подошёл твой предыдущий опыт (искали кандидата с релевантным опытом, например в банковской сфере)<br>
    - не совпали по твоим ожиданиям от работы и то что они могут предложить
    <br><br>
    Совет №7: обращайте внимание на красные флаги. Например:<br>
    - вакансия очень долго открыта<br>
    - не хотят говорить вилку по зарплате<br>
    - очень размытые требования к кандидату<br>
    - сфера деятельности компании из серого списка (ставки на спорт, сайты для взрослых, казино, микрозаймы)<br>
    - оформление по ГПХ или как самозанятый<br>
    - стартап, который оплачивает работу акциями
    <br><br>
    Совет №8: когда будете с эйчаром выбирать дату техсобеса, выбирайте день как можно раньше. Выучить что-то за несколько
    дней в любом случае не успеете, а вот потерять вакансию шансы увеличиваются.
    <br><br>
    Совет №9: не стоит переоценивать знание фреймворков, довольно редко задают вопросы на знание конкретного фреймворка
    и даже если спросят, то скорее всего какие то поверхностные вопросы. Чаще спрашивают фундаментальные вопросы:
    базы данных, асинхронность, знание языка.
    <br><br>
    Совет №10: не приходите на собеседование уставшим, в состоянии опьянения, в плохом самочувствии, лучше в
    таком случае объясниться и попросить перенести встречу.
    <br><br>
    Совет №11: если не знаете ответа, то не нужно мяться и делать долгих пауз, лучше сказать честно, что либо
    забыл, либо не сталкивался с таким в работе, но попробуешь порассуждать. Обращают внимание как ты отвечаешь
    на вопросы на которые не знаешь ответа, пробуешь ли рассуждать, смотрят за логикой рассуждений.
    <br><br>
    Совет №12: обязательно задавайте вопросы эйчару, отсутствие вопросов может произвести впечатление, что ты
    не сильно заинтересован в вакансии.
    <br><br>
    Совет №13: не спорьте с собеседующим, за исключением случаев, когда в задании ошибка. Даже если вы при нём загуглите
    и докажите что он неправ в реальности это скорее вызовет у него обиду, нежели восхищение какой вы умный и инициативный
    и умеете отстаивать свою точку зрения. Это не касается случаев, когда сам собеседующий приглашает подискутировать.
`